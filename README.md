# AOC 2025
Advent of code 2025, twelve days this year

This year I'm going to try to create a Python template to help me first solve the puzzle quickly in Python. Then, after both stars are in hand for that day, I will do a version in Rust along with any optimizations that seem interesting. The first few days might see both in the same day, but later days I would expect the Rust version to trail by days to weeks.  
I will also look at making some commonly used helper/example Python files. Things like a linked list, an example using NetworkX and a 2D matrix map load. These seem common enough in AOC and would be good practice to create

## Templates and Examples
* Python Template: I did make a template file for Python and it seemed fine when used with day 1. It's very simple, but includes a decorator to time the parts
* Didn't do any other classes, but didn't seem to really need them either. Might pull out the 2D matrix load and make that into something. Maybe.

## Python
* Day 1: Getting to a version that runs for both parts was straight forward. I didn't try any optimization as it seemed the type of puzzle where anything would finish pretty quickly. Part 1 was 0.001 seconds and part 2 was 0.04 seconds. I should have started on-time, made a file for the day and changed variables for the day ahead of time to get the two stars faster. In a day or two, I'm sure these will not matter ;-)
* Day 2: Part 1 was not too bad and part 2 was not terrible, but did take a bit of debugging to fix several errors. Part 2 also ran slow, but I think I will wait for the Rust version to see about making that better (tried regex with Rust instead, so still waiting on that)
* Day 3: I completed Part 1 in reasonable time, but I got bogged down by the new logic needed and a couple bugs in part 2. I need to think about moving to more, smaller functions over getting a first answer to try. Part 1 was 3.4 ms and part 2 6.0 ms
* Day 4: Some code to look around in the map, but not too bad and much could be reused for part 2. Part 1 took 11 ms and Part 2 was 190 ms
* Day 5: First day where part 2 cannot be solved with brute force. This was also the first time I ran out of memory instead of just waiting a long time and killing off the run. I used a range collapsing approach to solve (this has worked in previous years and I suspected straight away would be needed here). Could use clean-up, but done for now. Part 1 took 5.6 ms and part 2 34.7 ms
* Day 6: First part was easy, but the second part had a few formatting tricks. Errors in these needed to be debugged for a bit. Part 1 took 1.6 ms and part 2 3.7 ms
* Day 7: Like Day 5, the first part was fine, but the second part needed an elegant solution of tracking position sums by row. Part 1 ran in 2.8 ms and part 2 took 2.4 ms
* Day 8: This was the first day where I thought part 1 was also tricky. I started with a set based solution, but that was falling apart a bit. I moved to a graph solution with NetworkX and that worked pretty well. For part 2, I redid a lot of part 1 and checked for full connection after adding each pair. I could have saved some time in part 2 by reusing part 1 variables, but didn't want to move the scope of the variables, just getting the stars. I will probably see if I can reuse on the Rust version, but that will mean a apples to oranges comparison of run times. Part 1 took 0.72 seconds and part 2 was 4.4 seconds, so run times are increasing
* Day 9: Part 1 was quick to solve and run, but part 2 required some thought. First idea worked, but took a some time to run. Will save optimization ideas for the Rust implementation. Part 1 took 0.02 seconds and part 2 took 8.3 seconds
* Day 10: Part 1 took 14 seconds via brute force, but worked. Part 2 has no chance with brute force so tried with an equation solver first. This started breaking just with the first set because it gave fractional presses, but had a correct answer. Will try to loop this, but I don't have much hope it will work on the full example or real input. And... it's not working. I'm pretty sure I am setting up the constraints incorrectly, but can't figure out how to fix it for the last example line.  
I moved to using the Pulp module, but I still can't seem to figure out how to set this up correctly for each line.  
OK, figured it out with Pulp, but this was the hardest day so far. Part 1 took 14 seconds (via brute force) and part 2 was 2.8 seconds with the Pulp module. Having a good structure, I might be able to get SciPy to work now and I hope there is a solver crate for Rust
* Day 11: Part 1 I used NetworkX, made a graph and counted all paths. This didn't work for part 2 as there are too many paths. So I moved to a carried sum as I moved to each next node (assumed no loops) and put if the two target nodes had been visited in the node name. This worked and was not too bad to implement. Part 1 took 3.4 ms and part 2 took 10.0 ms
* Day 12: This is a hard part 1 and probably a case of the "bin packing" problem. If so, it is NP-hard and we will need some "good try" instead of a "best fit" given the input numbers. Let's try a possibility threshold first, because it is easy. We will take the total area of all the presents plus a constant and if that fits in the total tree area, we will say there is a packing and no otherwise. This is unlikely to work as the puzzle is almost certainly designed with some cases to make it not work. Still, looks like the example splits at 15% free space, so I will try that as my first guess.  
Amazingly, this worked and since part two is having all the other stars, I'm done! It almost felt like I cheated and got lucky though.


## Rust
* Day 1: Did you know that Rust "%" is not modulus, but remainder and can be negative? I also made part 2 in Rust more efficient, because it's Rust and that's part of the choice. Those two items made it take way longer than I though it would. Part 1 and 2 each took about 0.0003 seconds
* Day 2: Figured I would try the Rust regex library for this one. Had to figure out why grouping does not work. It's because the standard Rust regex crate does not support it for speed reasons. No problem, use the fancy-regex library. It took 58 seconds for part 1 with a short regex. Part 2 only needed a small regex change to work, but was also very slow at 59 seconds. It also seemed hard to manipulate stings in the right way to get everything to work (str vs. &str vs. String vs. &String). Guess I still need more practice with this in Rust. I will leave improving the speed for later, but I'm guessing the Python approach would run OK and would respond well to a thread pool to take each range with
* Day 3: Some frustration as I continue to get used to Rust's argument passing and ownership. Since I knew what was coming in part 2, I made a function that could take the number of batteries used as a parameter. Part 1 ran in 0.14 ms and part 2 in 0.20 ms. Since I used the same approach as with Python, probably a normal Rust speed-up factor
* Day 4: Not too bad to move to Rust. I could have refactored part1 to serve for part2 and had less code. Part 1 took 0.23 ms and part 2 took 3.7 ms. Since this was comparable to the Python approach, Rust was ~50x faster for each part
* Day 5: I looked to write a part 1 with ranges that could be reused for part 2. Again, it took some time to get this all typed correctly. Part 1 took 0.53 ms and part 2 was 200 nano seconds. So part 1 was a 10x speed-up vs. Python, but since it was also merging ranges in part 1, part 2 was a >100,000x speed-up. More fairly, a 76x speed-up overall
* Day 6: I asked Copilot if parse() takes care of whitespace for you. It said yes, but actually, it does not. That combined with the usual argument passing and ownership learning made the second part take a while. Part 1 ran in 0.11 ms and part 2 was 0.58 ms. If I pass back through, I might be able to remove some clone()s in part 2
* Day 7: I think I did this a little cleaner than the Python version. Part 1 took 0.39 ms and part 2 took 0.42 ms. About 5x faster than Python. This might be a place I could try converting from for loops to in-line iterators to see if it makes a speed difference
* Day 8: Going to try the set solution that was not working in Python. This way I will not be using a graph/networking crate.  
**Version 1:** I just got things running and used a wasteful method of completely rebuilding the circuits each time I added a added a connection. It worked, but was very slow for part 2. Part 1 took 0.16 seconds and part 2 was 14.2 seconds. So p1 was about 4x faster than Python and P2 was ~3x slower. I am going to do a check in here and improve this in parts  
**Version 2:** The worst thing in V1 is probably all the rework done just reusing get_circuits() from part 1. If we keep the circuits and just add each connection as it is made we should save lots of time. I am predicting more time than everything else combined (I didn't do a profile, but it seems very wasteful). This worked pretty well and put part at 0.17 seconds. In total now (part 1 and part 2) Rust is now about 15x faster  
**Version 3:** The next easy thing to do is not to do the work from part 1 again in part 2. I usually don't try to reuse between the parts, but let's keep going until I run out of ideas or get board with day 8. This works and the whole thing now runs in just over part2's V2 time. Rust is now ~29x faster. Still, we have some extra string manipulation and a lot of clone.()s. Let's do a refactor and see if we can fix some of that  
**Version 4:** Keeping the original strings saved about 10 ms, leaving total time at 167.5 ms. Got rid of one clone() and it didn't really do anything, but got rid of the one to build the list by distances between boxes and it ran about 3x faster (44.6 ms). So I am going to do a commit so the change is visible. Total speed up over Python is at 113x  
**Version 5:** Took out the square root, as we only need correct ordering, but that didn't make much difference, but saved 3 ms when I changed everything to i64 from f64 and was able to use the standard sort() instead of the custom sort function for distances. Then I made the two sort()s that I had the faster, unstable versions and that saved almost 8 ms. Total time now 33.7 ms, ~151x faster than Python now  
**Version 6:** Try careful use of only original strings with reference slices everywhere else to remove more clone()s? Somehow, it's slower at ~38 ms. It took a lot of doing to get everything from Strings to &str and it did seem to avoid a bunch of .clone()s so I don't know why it was not an improvement. I'm going to do a commit and then try the LLM suggestion for the add_circuit() function  
**Version 7:** Looks like the LLM version of add_circuit() takes the same time as mine. I'll admit it is a little more readable. On my side, it had a syntax error that needed fixing before it would work though. I think I will end my day 8 adventure here with version 5 as the fastest. (Side note: I asked Copilot for speedup options after I was done. It gave me several that were hallucinations, or I didn't understand them. It gave one that would probably work quite well, use a DSU (Disjoint Set Union). I didn't know what that was, but looks like it would replace my list (Vec) with a tree structure that could move around the "circuits" in the puzzle more efficiently because they are never in more than one)  
**Version 8:** I couldn't help myself and tried having Copilot rewrite with DSU. It worked and ran in ~18.5 ms. Yes, way outside an apples-to-apples comparison and not really mine anymore, but the Rust version is now 276x faster  
* Day 9: Part 1 is straight forward and runs quickly, even in debug. I used the same approach as the Python version and part 1 took 0.24 ms and part 2 took 87.2 ms. This is 95x faster in Rust. As I look back, it's not *exactly* the same as I see if the area is large enough to bother with intersection testing first in the Python version. I will make them match and try again. That improves the Rust version to 26.5 ms in part 2, so now Rust is 310x faster  
**Version 2:** Just for fun, I tried using i32 values for the tile x and y coordinates to see if it was any faster. It was by just more than 1 ms, or 4%
* Day 10: ...

## Things Learned This Year (in progress)
* Python is slower, but so easy. Yes I know it better at this point, however I think some of the following points will lend that observation some credibility
* The Rust operator % is remainder and not modulus. I assume this was done because remainder is faster to compute and is the same in many cases. In AOC, the wrap-around capability of modulus (even to a negative) is usually what I seem to want
* The default regex crate in Rust is missing some very common functionality. Every regex implementation seems to be a little different, but the Python one seems to hit the mark better
* The type matching in Rust means that is takes me longer to generate my Rust implementation, even when I already know the issues from having done the Python implementation. I don't think this would actually be the case in a very complex piece of software, but in AOC (short puzzle) it seems to add a lot of time. In day 3 I passed a vector incorrectly and it did not produce a compile error. The spot where the debugger showed the impact of that was also on a different line of the code when I made an unrelated vector change and was very confusing to debug. I assume I will get better at this over time, but it was time consuming to learn how this manifests and type checking does not 100% save you from passing values incorrectly
* The LLM can still hallucinate. It said that Rust's parse() will handle surrounding white space for you, but it will not. If you guess that Rust will do whatever is faster, you will probably be correct. Run trim().parse() if needed
* I am finding that I avoid Rust structs in my solutions, where I'm pretty sure I would use them in released/supported "real" code. This saves me the trouble of making the structs, but it makes the function definitions longer to use native types without them. I should probably return to one of the days (like day08 with a point struct) and resolve using structs and see if I am really saving anything and if the solution is more understandable with them
* Rust will not sort a Vec(list) of floats out-of-the-box.
* There are some good Rust, AOC repos. Will have to spend some more time looking at [this](https://github.com/maneatingape/advent-of-code-rust/tree/main/src/year2025) and [this](https://github.com/rene-d/advent-of-rust). The only (minor) issue is that they have supporting structure that you need to wade through to follow them
* Need to remember to look for supporting functions. The window() function on a Vec<> is an interesting one as an example
